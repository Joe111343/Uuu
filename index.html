<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>穩定定格播放器</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Oswald:wght@700&display=swap" rel="stylesheet">
<style>
html, body {
margin: 0; padding: 0; height: 100vh;
font-family: sans-serif;
color: white;
overflow: hidden;
}
#background {
position: fixed;
top: 0; left: 0; width: 100%; height: 100%;
background: url('背景1.jpg') no-repeat center center fixed;
background-size: cover;
transition: transform 0.05s ease-out;
transform-origin: center center;
z-index: -1;
}
#container {
position: fixed;
bottom: 30px;
left: 375px;
width: 300px;
height: 150px;
transform: rotate(-45deg);
transform-origin: bottom right;
clip-path: polygon(10% 0%, 90% 0%, 100% 50%, 90% 100%, 10% 100%, 0% 50%);
background: transparent;
z-index: 999;
position: relative;
overflow: hidden;
}
#imageCanvas {
position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;
image-rendering: pixelated;
z-index: 10;
}
#fullScreenParticleCanvas {
position: absolute;
top: 0; left: 0;
width: 100%; height: 100%;
z-index: 2;
pointer-events: none;
}
#topLeftText {
position: fixed; top: 10px; left: 10px;
font-size: 14px;
display: flex; flex-direction: column; gap: 6px;
user-select: none; z-index: 1000;
}
#limiterToggle label, #gainToggleBtn {
cursor: pointer; user-select: none;
font-size: 14px; display: flex; align-items: center; gap: 6px;
}
#limiterCheckbox { width: 16px; height: 16px; cursor: pointer; }
#gainPanel {
display: none; margin-top: 8px; gap: 6px;
align-items: center; user-select: none;
}
#gainSlider { width: 150px; }
#gainValueDisplay {
min-width: 40px; text-align: center; font-weight: bold;
}
button {
background: #444; border: none; color: #eee;
padding: 2px 6px; border-radius: 4px; cursor: pointer;
}
#thanks {
position: fixed; bottom: 36px; left: 10px;
font-size: 14px; user-select: none; z-index: 1000;
}
#spectrum {
position: fixed;
top: 50%; left: 50%;
transform: translate(-50%, -50%) rotate(-90deg);
width: 1000px; height: 120px;
pointer-events: none; z-index: 20;
background: transparent; border-radius: 8px;
}
#fileInput {
position: fixed; top: 10px; right: 10px; z-index: 100;
}
#playBtn {
position: fixed; top: 50%; left: 50%;
transform: translate(-50%, -50%);
z-index: 200;
font-size: 18px; padding: 10px 20px;
border: none; background: lime; color: black;
cursor: pointer; border-radius: 8px;
}
#volumeMeterContainer {
position: fixed; bottom: 10px; right: 60px;
width: 300px; height: 16px; background: #222;
border-radius: 8px; overflow: hidden; z-index: 100;
}
#volumeMeterBar {
height: 100%; width: 0%;
background: limegreen;
transition: width 0.1s linear, background 0.1s linear;
}
#oscilloscope {
position: fixed; top: 50%; left: 50%;
transform: translate(-50%, -50%);
z-index: 15;
border-radius: 50%;
background-color: transparent;
}
</style>
</head>
<body>
<div id="background">
<canvas id="fullScreenParticleCanvas"></canvas>
</div>
<div id="topLeftText">
趔陽不會陽bilibili
<div id="limiterToggle">
<label><input type="checkbox" id="limiterCheckbox" checked />限幅器</label>
</div>
<button id="gainToggleBtn">+</button>
<div id="gainPanel">
<input type="range" id="gainSlider" min="1" max="100" step="1" value="1" />
<span id="gainValueDisplay">1</span>
</div>
</div>
<div id="thanks">感謝 <span style="color:deepskyblue">@趔陽不會陽</span> 的BY player</div>
<div id="container">
<canvas id="imageCanvas" width="600" height="300"></canvas>
</div>
<canvas id="oscilloscope" width="200" height="200"></canvas>
<canvas id="spectrum"></canvas>
<input type="file" id="fileInput" accept=".mp3,.wav,.m4a" />
<button id="playBtn">▶ 播放音訊</button>
<div id="volumeMeterContainer"><div id="volumeMeterBar"></div></div>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
const imageCanvas = document.getElementById('imageCanvas');
const imageCtx = imageCanvas.getContext('2d');
const fullScreenParticleCanvas = document.getElementById('fullScreenParticleCanvas');
const particleCtx = fullScreenParticleCanvas.getContext('2d');
const background = document.getElementById('background');
fullScreenParticleCanvas.width = window.innerWidth;
fullScreenParticleCanvas.height = window.innerHeight;

const width = imageCanvas.width, height = imageCanvas.height;
const image = new Image();
image.src = 'R.png';
let imageLoaded = false;
let oswaldFontLoaded = false;
let frameBuffer = [], maxFrames = 4;
const smoothedOffsets = new Array(width).fill(0);
const smoothingFactor = 0.8;
let smoothedMax = 0;
let analyser, analyser_for_image, analyserL, analyserR, channelSplitter, channelMerger;
let dataArray, dataArray_for_image, freqArrayL, freqArrayR;
let audioCtx, source, volumeGain, limiter;
let lowpassFilter;
let limiterEnabled = true;
let gainValue = 1;
const volumeBase = 0.2;
const spectrumCanvas = document.getElementById('spectrum');
const spectrumCtx = spectrumCanvas.getContext('2d');
spectrumCanvas.width = 1000;
spectrumCanvas.height = 120;

const oscilloscopeCanvas = document.getElementById('oscilloscope');
const oscilloscopeCtx = oscilloscopeCanvas.getContext('2d');
const oscilloscopeWidth = oscilloscopeCanvas.width;
const oscilloscopeHeight = oscilloscopeCanvas.height;

// 已移除平滑變數，將直接使用即時頻率
let smoothedMaxFreq = 0;
const smoothingFactorFreq = 0.1;

const eqParams = [
  { frequency: 31, gain: 19 },
  { frequency: 62, gain: 18 },
  { frequency: 125, gain: 4.25 },
  { frequency: 250, gain: 2.55 },
  { frequency: 500, gain: 3.4 },
  { frequency: 1000, gain: 1.7 },
  { frequency: 2000, gain: 2.55 },
  { frequency: 4000, gain: 5.1 },
  { frequency: 8000, gain: 9.35 },
  { frequency: 16000, gain: 13.6 }
];
let eqNodes = [];

image.onload = () => { imageLoaded = true; draw(); };
document.fonts.ready.then(() => {
  if (document.fonts.check("20px Oswald")) {
    oswaldFontLoaded = true;
    console.log('Oswald font loaded.');
  }
});
const numberImages = {};
const digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'hz'];
let imagesLoadedCount = 0;
let allImagesLoaded = false;
function loadImages() {
  digits.forEach(digit => {
    const img = new Image();
    img.src = `${digit}.jpg`;
    img.onload = () => {
      imagesLoadedCount++;
      if (imagesLoadedCount === digits.length) {
        allImagesLoaded = true;
      }
    };
    numberImages[`${digit}`] = img;
  });
}
loadImages();
function drawImageScaledCenter(ctx, img, w, h) {
  const scale = Math.min(w / img.width, h / img.height);
  const iw = img.width * scale, ih = img.height * scale;
  ctx.drawImage(img, (w - iw) / 2, (h - ih) / 2, iw, ih);
}

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = Math.random() * 5 + 2;
    this.vx = (Math.random() - 0.5) * 10;
    this.vy = (Math.random() - 0.5) * 10;
    this.alpha = 1;
    this.shrink = Math.random() * 0.05 + 0.01;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.size -= this.shrink;
    this.alpha -= 0.01;
  }

  draw() {
    particleCtx.fillStyle = `rgba(255, 0, 0, ${Math.max(0, this.alpha)})`;
    particleCtx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
  }
}

const particles = [];
const particleSpawnRate = 2.5;

function draw() {
  requestAnimationFrame(draw);
  if (!imageLoaded) { imageCtx.clearRect(0, 0, width, height); return; }

  if (!analyserL || !analyserR) {
    imageCtx.clearRect(0, 0, width, height);
    drawImageScaledCenter(imageCtx, image, width, height);
    return;
  }

  analyser.getByteTimeDomainData(dataArray);
  analyser_for_image.getByteTimeDomainData(dataArray_for_image);
  analyserL.getByteFrequencyData(freqArrayL);
  analyserR.getByteFrequencyData(freqArrayR);

  oscilloscopeCtx.clearRect(0, 0, oscilloscopeWidth, oscilloscopeHeight);
  oscilloscopeCtx.strokeStyle = 'lime';
  oscilloscopeCtx.lineWidth = 2;
  oscilloscopeCtx.beginPath();

  let centerOscX = oscilloscopeWidth / 2;
  let centerOscY = oscilloscopeHeight / 2;
  let radius = Math.min(oscilloscopeWidth, oscilloscopeHeight) / 2 - 50;

  for (let i = 0; i < dataArray.length; i++) {
    const v = dataArray[(i * 512 / width) | 0] / 128.0 - 1;
    const angle = i * Math.PI * 2 / dataArray.length;
    const x = centerOscX + Math.cos(angle) * radius * (1 + v * 0.3);
    const y = centerOscY + Math.sin(angle) * radius * (1 + v * 0.3);

    if (i === 0) {
        oscilloscopeCtx.moveTo(x, y);
    } else {
        oscilloscopeCtx.lineTo(x, y);
    }
  }

  oscilloscopeCtx.closePath();
  oscilloscopeCtx.stroke();
  
  const offCanvas = document.createElement('canvas');
  offCanvas.width = width; offCanvas.height = height;
  const offCtx = offCanvas.getContext('2d');
  drawImageScaledCenter(offCtx, image, width, height);
  const srcData = offCtx.getImageData(0,0,width,height);
  const dstData = offCtx.createImageData(width,height);
  const srcPixels = srcData.data, dstPixels = dstData.data;
  const halfH = height >> 1;

  const nyquist = audioCtx.sampleRate / 2;
  const binSize = nyquist / freqArrayL.length;
  const cutoffHz = 100;
  const lowBin = Math.floor(cutoffHz / binSize);
  let weightedSum = 0, totalWeight = 0;
  for (let i = 0; i <= lowBin; i++) {
    const w = 1 - (i / lowBin);
    weightedSum += ((freqArrayL[i] || 0) + (freqArrayR[i] || 0)) / 2 * w;
    totalWeight += w;
  }
  const lowPower = weightedSum / totalWeight;
  
  // *** 這行是修改的部分：直接使用即時值，沒有平滑處理 ***
  // smoothedMax = smoothedMax * 0.9 + lowPower * 0.1;
  smoothedMax = lowPower;

  for (let y = 0; y < halfH; y++) {
    for (let x = 0; x < width; x++) {
      const i = (y * width + x) * 4;
      const index = Math.floor(x * dataArray_for_image.length / width);
      const rawOffset = (dataArray_for_image[index] / 255 - 0.5);
      const newOffset = rawOffset * (smoothedMax / 255) * volumeBase * gainValue * 250;
      smoothedOffsets[x] = smoothedOffsets[x] * smoothingFactor + newOffset * (1 - smoothingFactor);
      let offset = smoothedOffsets[x];
      let newY = y + Math.floor(offset);
      newY = Math.max(0, Math.min(height - 1, newY));
      const j = (newY * width + x) * 4;
      dstPixels[j] = srcPixels[i];
      dstPixels[j+1] = srcPixels[i+1];
      dstPixels[j+2] = srcPixels[i+2];
      dstPixels[j+3] = srcPixels[i+3];
    }
  }
  for (let y = halfH; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = (y * width + x) * 4;
      dstPixels[i] = srcPixels[i];
      dstPixels[i+1] = srcPixels[i+1];
      dstPixels[i+2] = srcPixels[i+2];
      dstPixels[i+3] = srcPixels[i+3];
    }
  }

  frameBuffer.push(dstData);
  if (frameBuffer.length > maxFrames) frameBuffer.shift();

  imageCtx.clearRect(0, 0, width, height);
  for (let i = 0; i < frameBuffer.length; i++) {
    imageCtx.globalAlpha = (i + 1) / frameBuffer.length / 1.5;
    imageCtx.putImageData(frameBuffer[i], 0, 0);
  }
  imageCtx.globalAlpha = 1;

  spectrumCtx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
  const nyquist2 = audioCtx.sampleRate / 2;
  const binsize2 = nyquist2 / freqArrayL.length;
  const starthz = 0, endhz = 100;
  const startbin = Math.floor(starthz / binsize2);
  const endbin = Math.min(freqArrayL.length - 1, Math.floor(endhz / binsize2));
  const totalbins = endbin - startbin;
  const centerx = spectrumCanvas.width / 2;
  const centery = spectrumCanvas.height / 2;

  spectrumCtx.beginPath();
  if (freqArrayL) {
    for (let i = 0; i <= totalbins; i++) {
      const freqIndex = startbin + i;
      const val = (freqArrayL[freqIndex] || 0) / 255 * 2;
      const angle = (i / totalbins) * Math.PI;
      const r = val * 25;
      const x = centerx + r * Math.cos(angle);
      const y = centery - r * Math.sin(angle);
      if (i === 0) spectrumCtx.moveTo(x, y);
      else spectrumCtx.lineTo(x, y);
    }
    spectrumCtx.lineTo(centerx, centery);
  }
  spectrumCtx.closePath();
  spectrumCtx.fillStyle = 'rgba(255, 165, 0, 0.8)';
  spectrumCtx.fill();

  spectrumCtx.beginPath();
  if (freqArrayR) {
    for (let i = 0; i <= totalbins; i++) {
      const freqIndex = startbin + i;
      const val = (freqArrayR[freqIndex] || 0) / 255 * 2;
      const angle = (i / totalbins) * Math.PI;
      const r = val * 25;
      const x = centerx + r * Math.cos(angle);
      const y = centery + r * Math.sin(angle);
      if (i === 0) spectrumCtx.moveTo(x, y);
      else spectrumCtx.lineTo(x, y);
    }
    spectrumCtx.lineTo(centerx, centery);
  }
  spectrumCtx.closePath();
  spectrumCtx.fillStyle = 'rgba(0, 255, 255, 0.8)';
  spectrumCtx.fill();

  if (freqArrayL && freqArrayR && allImagesLoaded) {
    let maxVolume = 0;
    let maxBinIndex = 0;
    for (let i = startbin; i <= endbin; i++) {
      const combinedVolume = ((freqArrayL[i] || 0) + (freqArrayR[i] || 0)) / 2;
      if (combinedVolume > maxVolume) {
        maxVolume = combinedVolume;
        maxBinIndex = i;
      }
    }
    const maxFreqHz = Math.floor(maxBinIndex * binsize2);
    // 移除平滑處理，直接使用即時頻率
    // smoothedMaxFreq = smoothedMaxFreq * smoothingFactorFreq + maxFreqHz * (1 - smoothingFactorFreq);
    // const freqString = Math.floor(smoothedMaxFreq).toString();
    const freqString = maxFreqHz.toString();
    
    const imageScale = 0.05;
    let totalWidth = 0;
    for (let i = 0; i < freqString.length; i++) {
        const digit = freqString.charAt(i);
        if (numberImages[digit]) {
            totalWidth += numberImages[digit].width * imageScale;
        }
    }
    if (numberImages['hz']) {
        totalWidth += numberImages['hz'].width * imageScale;
    }

    const digitHeight = (numberImages['1']?.height || 0) * imageScale;

    // Use the max frequency point to position the text
    const textRadiusOffset = -5;
    const peakAngle = (maxBinIndex / totalbins) * Math.PI; // angle based on max freq
    const peakRadius = (maxVolume / 255 * 2) * 25; // radius of the peak on the spectrum
    
    // Original frequency text drawing
    const textX = centerx + (peakRadius + textRadiusOffset) * Math.cos(peakAngle);
    const textY = centery - (peakRadius + textRadiusOffset) * Math.sin(peakAngle);

    spectrumCtx.save();
    spectrumCtx.translate(textX, textY);
    spectrumCtx.rotate(Math.PI / 2); // 90 degrees clockwise
    
    let drawX = -(totalWidth / 2);
    const drawY = -(digitHeight / 2);

    for (let i = 0; i < freqString.length; i++) {
      const digit = freqString.charAt(i);
      if (numberImages[digit]) {
        const img = numberImages[digit];
        const scaledWidth = img.width * imageScale;
        const scaledHeight = img.height * imageScale;
        spectrumCtx.drawImage(img, drawX, drawY, scaledWidth, scaledHeight);
        drawX += scaledWidth;
      }
    }

    if (numberImages['hz']) {
      const img = numberImages['hz'];
      const scaledWidth = img.width * imageScale;
      const scaledHeight = img.height * imageScale;
      spectrumCtx.drawImage(img, drawX, drawY, scaledWidth, scaledHeight);
    }
    spectrumCtx.restore();

    // Flipped frequency text drawing
    const flippedTextX = centerx + (peakRadius + textRadiusOffset) * Math.cos(peakAngle);
    const flippedTextY = centery + (peakRadius + textRadiusOffset) * Math.sin(peakAngle);
    
    spectrumCtx.save();
    spectrumCtx.translate(flippedTextX, flippedTextY);
    spectrumCtx.rotate(-Math.PI / -2); // 90 degrees counter-clockwise
    
    let flippedDrawX = -(totalWidth / 2);
    const flippedDrawY = -(digitHeight / 2);

    for (let i = 0; i < freqString.length; i++) {
      const digit = freqString.charAt(i);
      if (numberImages[digit]) {
        const img = numberImages[digit];
        const scaledWidth = img.width * imageScale;
        const scaledHeight = img.height * imageScale;
        spectrumCtx.drawImage(img, flippedDrawX, flippedDrawY, scaledWidth, scaledHeight);
        flippedDrawX += scaledWidth;
      }
    }

    if (numberImages['hz']) {
      const img = numberImages['hz'];
      const scaledWidth = img.width * imageScale;
      const scaledHeight = img.height * imageScale;
      spectrumCtx.drawImage(img, flippedDrawX, flippedDrawY, scaledWidth, scaledHeight);
    }
    spectrumCtx.restore();
  }
  let sumSquares = 0;
  for (let i = 0; i < dataArray_for_image.length; i++) {
    const val = (dataArray_for_image[i] - 128) / 128;
    sumSquares += val*val;
  }
  const rms = Math.sqrt(sumSquares / dataArray_for_image.length);
  const db = 20 * Math.log10(rms || 0.00001);
  const percent = Math.min(100, Math.max(0, ((db+60)/60)*100));
  const meter = document.getElementById('volumeMeterBar');
  if (meter) {
    meter.style.width = percent + '%';
    meter.style.background = (db > -15) ? 'red' : 'limegreen';
  }
  
  const numParticlesToSpawn = Math.floor(rms * particleSpawnRate * 5);
  for (let i = 0; i < numParticlesToSpawn; i++) {
    particles.push(new Particle(fullScreenParticleCanvas.width / 2, fullScreenParticleCanvas.height / 2));
  }

  particleCtx.clearRect(0, 0, fullScreenParticleCanvas.width, fullScreenParticleCanvas.height);
  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].draw();
    if (particles[i].size <= 0 || particles[i].alpha <= 0) {
      particles.splice(i, 1);
    }
  }
  
  const minRmsThreshold = 0.05;
  let shakeMagnitude = 0;
  if (rms > minRmsThreshold) {
    shakeMagnitude = (rms - minRmsThreshold) * 50;
  }

  let shakeX = (Math.random() - 0.5) * shakeMagnitude;
  let shakeY = (Math.random() - 0.5) * shakeMagnitude;
  let scaleMagnitude = 1 + rms * 0.25;
  background.style.transform = `translate(${shakeX}px, ${shakeY}px) scale(${scaleMagnitude})`;
}

window.addEventListener('resize', () => {
  fullScreenParticleCanvas.width = window.innerWidth;
  fullScreenParticleCanvas.height = window.innerHeight;
});

document.getElementById('limiterCheckbox').addEventListener('change', e => {
  limiterEnabled = e.target.checked;
  connectAudioNodes();
});
document.getElementById('gainToggleBtn').addEventListener('click', () => {
  const panel = document.getElementById('gainPanel');
  panel.style.display = (panel.style.display === 'flex') ? 'none' : 'flex';
});
document.getElementById('gainSlider').addEventListener('input', e => {
  gainValue = parseInt(e.target.value, 10);
  document.getElementById('gainValueDisplay').textContent = gainValue;
  if (volumeGain) volumeGain.gain.value = volumeBase * gainValue;
});

function connectAudioNodes() {
  if (!source) return;
  try {
    source.disconnect();
    volumeGain.disconnect();
    if (limiter) limiter.disconnect();
    if (analyser) analyser.disconnect();
    if (analyser_for_image) analyser_for_image.disconnect();
    analyserL.disconnect();
    analyserR.disconnect();
    channelSplitter.disconnect();
    if (channelMerger) channelMerger.disconnect();
    if (lowpassFilter) lowpassFilter.disconnect();
    eqNodes.forEach(node => node.disconnect());
  } catch (e) { }

  let currentNode = volumeGain;
  source.connect(currentNode);

  eqNodes.forEach(node => {
    currentNode.connect(node);
    currentNode = node;
  });

  if (limiterEnabled) {
    currentNode.connect(limiter);
    limiter.connect(audioCtx.destination);
  } else {
    currentNode.connect(audioCtx.destination);
  }

  currentNode.connect(lowpassFilter);
  lowpassFilter.connect(analyser);

  currentNode.connect(analyser_for_image);
  
  channelMerger = audioCtx.createChannelMerger(2);
  currentNode.connect(channelMerger, 0, 0);
  currentNode.connect(channelMerger, 0, 1);
  
  channelMerger.connect(channelSplitter);
  channelSplitter.connect(analyserL, 0);
  channelSplitter.connect(analyserR, 1);

  if (volumeGain) volumeGain.gain.value = volumeBase * gainValue;
}

const fileInput = document.getElementById('fileInput');
const playBtn = document.getElementById('playBtn');
let audioFile;
fileInput.addEventListener('change', e => {
  if (e.target.files.length > 0) {
    audioFile = e.target.files[0];
    if (playBtn) playBtn.style.display = 'block';
  }
});
playBtn.addEventListener('click', async () => {
  if (!audioFile) return;
  if (audioCtx) await audioCtx.close();
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  analyser = audioCtx.createAnalyser();
  analyser_for_image = audioCtx.createAnalyser();
  analyserL = audioCtx.createAnalyser();
  analyserR = audioCtx.createAnalyser();
  channelSplitter = audioCtx.createChannelSplitter(2);

  analyser.fftSize = 2048;
  analyser_for_image.fftSize = 4096;
  analyserL.fftSize = 16384;
  analyserR.fftSize = 16384;

  dataArray = new Uint8Array(analyser.fftSize);
  dataArray_for_image = new Uint8Array(analyser_for_image.fftSize);
  freqArrayL = new Uint8Array(analyserL.frequencyBinCount);
  freqArrayR = new Uint8Array(analyserR.frequencyBinCount);

  audio = new Audio();
  audio.src = URL.createObjectURL(audioFile);
  audio.crossOrigin = "anonymous";
  audio.loop = false;

  source = audioCtx.createMediaElementSource(audio);
  volumeGain = audioCtx.createGain();
  volumeGain.gain.value = volumeBase * gainValue;

  eqNodes = eqParams.map(param => {
    const eq = audioCtx.createBiquadFilter();
    eq.type = 'peaking';
    eq.frequency.value = param.frequency;
    eq.Q.value = 1.0;
    eq.gain.value = param.gain;
    return eq;
  });

  limiter = audioCtx.createDynamicsCompressor();
  limiter.threshold.value = -5;
  limiter.knee.value = 5;
  limiter.ratio.value = 5;
  limiter.attack.value = 0.003;
  limiter.release.value = 0.2;

  lowpassFilter = audioCtx.createBiquadFilter();
  lowpassFilter.type = 'lowpass';
  lowpassFilter.frequency.value = 100;

  connectAudioNodes();
  await audio.play();
  if (playBtn) playBtn.style.display = 'none';
});

});
</script>

</body>
</html>
